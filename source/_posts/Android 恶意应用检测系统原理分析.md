---
title: Android 恶意应用检测系统原理分析
date: 2018-03-16T14:47:12.000Z
categories: Android
tag: Android
toc: true
---

安卓恶意软件检测：系统调用日志＋机器学习算法:<https://cloud.tencent.com/developer/article/1016644><br>
深度安卓恶意软件检测系统：用卷积神经网络保护你的手机：<http://www.bijishequ.com/detail/430137?p=><br>
基于随机森林分类方法的Android平台恶意应用检测方法:<https://patents.google.com/patent/CN105550583A/zh><br>
基于机器学习算法的 Android 恶意程序检测系统:<https://patents.google.com/patent/CN104123500B/en><br>
基于BHNB的细粒度的Android恶意应用检测模型：<http://www.shcas.net/jsjyup/pdf/2017/10/%E5%9F%BA%E4%BA%8EBHNB%E7%9A%84%E7%BB%86%E7%B2%92%E5%BA%A6%E7%9A%84Android%E6%81%B6%E6%84%8F%E5%BA%94%E7%94%A8%E6%A3%80%E6%B5%8B%E6%A8%A1%E5%9E%8B.pdf><br>
基于 API 调用的抗混淆 Android 应用相似性检测方法:<http://sei.pku.edu.cn/~yaoguo/papers/Wang-ScienceChina-14.pdf><br>
基于代码克隆检测技术的 Android 应用重打包检测<http://sei.pku.edu.cn/~yaoguo/papers/Wang-ScienceChina-14.pdf><br>

# 静态分析

在不运行恶意软件的情况下执行恶意软件。 反编译、模式识别、解密等。因为未知的恶意应用因为使用混淆、加密等技术会使签名不同，所以静态分析方法不能识别未知的恶意软件。

# 动态分析

动态分析方法可以检测应用的行为，比如网络访问、运行时发送短信和打电话等。动态分析是在沙箱环境下运行的，这样可以防止恶意软件感染真实的运行环境。

# 方法

## 使用系统调用日志进行恶意软件检测

1. 生成系统调用日志。
2. 卡方 (Chi-square)过滤，并生成数据集。
3. 利用机器学习算法进行检测。

# #

## 使用算法

朴素贝叶斯算法、随机森林算法和随机下降梯度算法(Stochastic Descent Gradient Algorithm)。机器学习的结果会输出到Weka软件中进行分析。

# Apk文件分析

Apk文件实质是一个压缩包，解压缩之后的文件夹主要包含Dalvik字节码，UI布局，资源文件，配置文件，签名信息等，

## 重打包类型

1. 通过替换广告库来谋取利益. 很大一部分的重打包应用是通过替换掉原应用的广告库, 或者替 换广告库中的客户标识 (Client ID) 来谋取利益. 目前 Android 应用的主要盈利方式是通过广告点击, 因此恶意开发者目的是通过这样的方式来获得收入. 这种行为造成了原应用的广告流量减少, 侵犯了 原应用作者的知识产权并且导致收入的损失. 检测中发现, 有些重打包应用直接使用了跟原应用相同 的名称, 用户很难区分是否是合法的应用. 而另外有些重打包应用直接换了名字和界面中的图片, 以 另外一个新的应用身份出现.
2. 汉化版和去广告版. 一些被检测出来的重打包应用自称是汉化版和去广告版, 但是通过检查代 码发现很多汉化版和去广告版的应用中使用的广告库更多, 申请的权限也更多, 给用户带来更大的安 全隐患. 这些应用是以汉化版和去广告版为噱头来吸引用户下载, 但是其实很多应用并不可靠


## 业界使用技术

1. DroidMOSS 在 Dalvik 字节码层进行应用重打包检测. DroidMOSS 提取 Dalvik 字节码中的操作码序列, 使用模糊散列的方法对应用程序产生一个指纹签名并作为特征, 通过比较应用程序指纹之间的编辑距离得到应用程序的相似度. 类似的, Juxtapp[5] 使用了特征散列 的方法对应用程序产生指纹签名并且以它们之间的 Jaccard 距离作为重打包的判断依据. DroidMOSS 和 Juxtapp 都是从 Dalvik 字节码中提取静态的特征信息, 并且使用不同的散列技术来将这些静态信 息表示成向量从而进行比较. 这种比较方法的优点是简单快速, 能够很容易的扩展到大规模应用的比 较. 但是重打包应用很容易就能逃避这种检查技术, 比如最简单的交换代码顺序或者增添删除操作码 就会导致应用程序的指纹发生改变从而导致检测方法失效.

2. DNADroid通过比较应用的程序依赖图 (PDG) 来检测重打包应用. 基于程序依赖图的检测技 术是代码克隆检测中经常使用的方法. 它使用了程序的语义信息, 因此检测的准确率应该会比较高. 但是基于程序依赖图的检测方法执行效率是个问题. 在 DNADroid 中, 作者使用 Hadoop Mapreduce 并行计算框架在四台机器上执行应用的重打包检测, 但是平均每分钟只能比较 0.71 个应用对. 因此, 这种方法的扩展性不高, 很难应用到应用市场级别数十万的应用检测.

3. Zhou 等人 [7] 提出了基于程序依赖图的模块解耦技术来把应用程序的代码划分为核心模块和次 要模块. 首先根据 Dalvik 字节码建立程序依赖图, 使用聚类算法来将程序依赖图中的包聚类. 然后根 据应用程序配置文件的一些基本信息 (活动、服务、内容提供者、接收者等) 来确定已经聚类的模块中 哪些是主要模块和次要模块. 应用程序之间的比较是通过从主模块中提取出来的一些语义的信息, 如 应用程序申请的权限和 Android API 的调用等. 作者同时提出了一个线性搜索算法来降低在一堆应 用中检测重打包的复杂度, 即不需要两两之间都要比较, 只需比较 O(n logn) 个应用对即可.

## 可用做法（猜测）

1. 基于重打包的判断条件，为了高效率提取核心代码，可能需要过滤正常的第三方库，如广告库，社交库，开发库等，过滤条件（文件结构目录，文件MD5等），Sdk文件目录可以尽量使用第三方路径。

2. Keytool 可以用来提取应用程序的签名信息，签名MD5，SHA具有唯一性，所以每次签名必重新生成签名。

3. Android5.0 以后安全性要求较高的应用应该使用 window.setFlag (LayoutParam.FLAG_SECURE) 禁止录屏。
